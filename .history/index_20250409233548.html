
<meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<html> 
<head> 
  <link type="text/css"
        rel="stylesheet"
        href="style.css">

  <script src="https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js"></script>
<title>Hritij R</title> 
</head> 
<body> 
<h1>Hritij Rana</h1> 
<div style="display:grid;grid-template-columns: 80% 20%;">
  <div style="float:left;">
    <p>
    I'm a '24 &nbsp;Mathematics and Computing undergrad. from <a href="http://nsut.ac.in/en/home">Netaji Subhas University of Technology</a>.
    I am an ex-competitive coder and prompt engineer at <a href="https://softage.ai/">softage.ai</a>. I have a bittersweet relation with LLMs where sometimes it's fun to make it reason and other times its not.
    I was part of the team responsible for creating agentic data for a computer-use agent for <a href="https://generalagents.com/">general agents</a>.
    These days I am on a lookout to join a close knit AI startup.
    </p>
    <p>
    My areas of interest include on-device AI. I think it won't be long when LMs could run locally on our phones and PCs.
    We've already been seeing great effort by hardware giants in this area. Drop an email, and let's chat — even if it's just a silly idea!
    </p>

    <ul class="bulletless">
    <b>Email: </b> <a href="hritijrana07@gmail.com">hritijrana07@gmail.com</a>   
    </ul>
    <p>
    <b>Links:</b>
    <a href="https://www.linkedin.com/in/hritijrana/" target="_blank">Linkedin</a> &bull;  
    <a href="https://github.com/Rhriti" target="_blank">GitHub</a> &bull; 
    <a href="https://leetcode.com/u/_parshuram/" target="_blank">LeetCode</a> &bull; 
    <a href="https://www.codechef.com/users/hrjr" target="_blank">CodeChef</a>
    </p>

  </div>
  <div style="float:left">  
    <img class="mug center" style="max-width:80%" src="cc.jpeg" alt="Hritij Rana"> 
  </div>

</div>

<hr>
<div class="navigation_list">
  <h2>
    <a href="#project_place" onclick="showContent('project_place',event)">Projects &nbsp;[O.S]</a> &bull;
    <a href="#blog_place" onclick="showContent('blog_place',event)">Blog</a> &bull;
    <a href="#award_place" onclick="showContent('award_place',event)">Awards</a> 
  </h2>
</div>

<div id="places">

<div id="project_place" class="">
  <table>
    <colgroup>
      <col style="max-width: 50%">
      <col style="max-width: 50%">
    </colgroup>
    <tbody>


    <tr>
      <td>
        <div class=highlights>
          <b><a href="https://aijudges.in">AI Judge</a></b><br>
          <p>
            What would happen if you let AI reason for the hackathon winner?
            <br><br>
            I believe that judgement should be 100% transparent which clearly is not the case in any hackathon platform yet. 
            The candidates must know why one submission deserves to be the winner more than the other. 
            <br><br>
            <b>The Story : </b>
            An AI Judge that compares every other submission, taking submission video and description into 
            consideration to reason and announce winner based on the judging criteria and winner category.It's a heads-on 1v1 battle among all the submissions ⚔️
            <br>
            Don't trouble yourself with the thoughts of who's gonna be the winner. sit back and let the 'AI judge' decide !   
          </p>
          <blockquote class="twitter-tweet"><p lang="en" dir="ltr">I know how anxious it feels to wait for the winner announcement after a hefty <a href="https://twitter.com/devpost?ref_src=twsrc%5Etfw">@devpost</a> hackathon. I&#39;ve built this AI tool that does a head-on 1v1 for all the submission to arrive at a winner. <a href="https://t.co/nOlPbWFY8q">pic.twitter.com/nOlPbWFY8q</a></p>&mdash; Hritij Rana (@HritijRana) <a href="https://twitter.com/HritijRana/status/1893597079722754079?ref_src=twsrc%5Etfw">February 23, 2025</a></blockquote> 
        </div>
      </td>
    </tr>


    <tr>
      <td>
        <div class=highlights>
          <b><a href="https://devpost.com/software/namer-gemini-nano-powered-file-downloader" target="_blank">NameR : Gemini Nano powered PDF downloader</a></b><br>
          <p>
            A file downloader that suggests file name on the go, so you never have to worry about absurd default filenames
            <br><br>
            <b>The Story : </b>The idea to built such a thing didn't come all of a sudden. There were countless times when I wasted hours searching for a specific PDF—simply because I hadn’t renamed it to something meaningful when I downloaded it. I’d end up scrolling through a chaotic list of files, unsure of their names. This frustration became all too common. The trigger point came when I was at a medical clinic, scrolling through my phone, searching for past medical records with absurd filenames that I never bothered renaming. That moment made me realize how a simple oversight can lead to significant inconvenience.
            <br><br>
            Privacy was a major concern as we don't want any sensitive records go for analysis. The project came to life when Google announced its <a href="https://googlechromeai.devpost.com/">Google's Chrome Built-in AI Challenge</a>.
            This allowed us to leverage its on-device AI i.e Gemini Nano. We've utilized Gemini Nano to analyse the file locally and suggest a filename during download. The winners are due on January 13, 2025.
            <br><br>
            
              <!-- <iframe width="300" height="200" src="https://www.youtube.com/embed/Zgf83liLl7o?si=gsIaiPbLSeeOGkZs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe> -->
              <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; border-radius: 15px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                <iframe 
                  style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 15px;" 
                  src="https://www.youtube.com/embed/Zgf83liLl7o?si=gsIaiPbLSeeOGkZs" 
                  frameborder="0" 
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                  allowfullscreen>
                </iframe>
              </div>
              
          </p>
        </div>
      </td>
      <td class="image">
        <img class="side-image" src="images/namer.png" style="padding: 0px 16px">
      </td>
    </tr>

    <tr>
      <td>
        <div class=highlights>
          <b><a href="https://huggingface.co/Hritijr/en_pipeline" target="_blank">Named Entity Recognition for Automotive Vehicles</a></b><br>
            <p>
              Fine-tuned SpaCy’s English model to perform Named entity recognition on tags like components, failure issue, vehicle model and corrective action.
            <br><br>
            <b>The Story : </b> This was part of an assignment where we needed to guess tags related to vehicle entites from an unstructured 
            text log.     
          </p>
        </div>
      </td>
      <td class="image">
        <img class="side-image" src="images/vehicle.png" style="padding: 0px 16px">
      </td>
    </tr>

    <tr>
      <td>
        <div class=highlights>
          <b><a href="https://github.com/Rhriti/mistralAI-hackathon" target="_blank">Submission to Mistral-AI Hackathon</a></b><br>
            <p>
              One of the steps involved in cleaning a video is trimming unnecessary portion from it. For instance, expert labelled videos 
              like 'Minecraft gameplay' don't require video segement of user setting up the game. This is a manual task.
              I've tried to automate this leveraing LLM and video transcript. 

            <br><br>
            <b>The Story : </b> 
            Being in the operations-AI industry for a while I realized that video cleaning is a tiresome task and 
            one of the steps involved in video cleaning is to timestamp relevant portion of the video which is then used to train an AI Agent. 
            So why not leverage LLM and video transcript for this task!
          </p>
        </div>
      </td>
      <td class="image">
    </tr>

    </tbody>
  </table>

</div>

<div id="award_place" class="hidden highlights">
  <ul style="list-style-type: disc;">
    <li style="margin-bottom: 5px;">Won several hackathons and coding competitions at college and national level</li>
    <li style="margin-bottom: 5px;">Secured <b>under 100</b> global rank @ renowned competitive coding platform like <b>CodeChef</b></li>
    <li style="margin-bottom: 5px;">Top <b>2 percentile</b> at JEE Mains 2020 and top <b>.5 percentile</b> in Physics at JEE Mains 2020 </li>
  </ul>
  
  

</div>

 <div id="blog_place" class="hidden">
  <table>
    <tbody>

    </tbody>
  </table>
 </div>
<hr>


</div> <!-- end places -->
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<script>

  function showContent(sectionId, event) {
    event.preventDefault();
    const elements = document.querySelectorAll("[id$='_place']");
    elements.forEach((element) => element.classList.add('hidden'));
    document.getElementById(sectionId).classList.remove('hidden');
  }

  const converter = new showdown.Converter();
  function fetchBlogs() {
  const blogFiles = ['blog4.md','blog3.md', 'blog2.md', 'blog1.md'];
  const blogSection = document.querySelector("#blog_place tbody");

  const fetchPromises = blogFiles.map(blogFile => {
    const blogPath = `blogs/${blogFile}`;
    return fetch(blogPath)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to load ${blogFile}`);
        }
        return response.text();
      })
      .then(markdown => {
        return { blogFile, content: markdown }; // Return both file name and content
      });
  });

  Promise.all(fetchPromises)
    .then(blogs => {
      blogs.forEach(blog => {
        const blogRow = document.createElement('tr');
        const blogCell = document.createElement('td');
        blogCell.innerHTML = `<div class="highlights">${blog.content}</div>`;
        blogRow.appendChild(blogCell);
        blogSection.appendChild(blogRow);
      });
    })
    .catch(error => console.error("Error loading blogs:", error));
}

  document.addEventListener("DOMContentLoaded", fetchBlogs);
</script>


</body> 

</html>
